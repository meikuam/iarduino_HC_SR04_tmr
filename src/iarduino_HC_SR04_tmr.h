//	Библиотека для работы с ультразвуковым датчиком расстояния HC-SR04: http://iarduino.ru/shop/Sensory-Datchiki/ultrazvukovogo-datchika-hc-sr04-rasstoyaniya-dvizheniya.html
//  Версия: 1.0.0
//  Последнюю версию библиотеки Вы можете скачать по ссылке: https://iarduino.ru/file/548.html
//  Подробное описание функции бибилиотеки доступно по ссылке: http://wiki.iarduino.ru/page/ultrazvukovoy-datchik-izmereniya-rasstoyaniya-hc-sr04/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_HC_SR04_tmr_h
#define iarduino_HC_SR04_tmr_h

#if defined(ARDUINO) && (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

#if defined(__AVR_ATmega32U4__)													//	Если используется плата на базе микроконтроллера ATmega32U4 (Arduino Micro или Arduino Leonardo), то ...
#if !defined(TCCR2A)															//	Если Arduino IDE не знает, что у этих микроконтроллеров есть второй аппаратный таймер, то ...
	#define TCCR2A					(*(uint8_t*)0xB0)							//	Определяем смещение для регистра TCCR2A - регистр выбора режима
	#define COM2A1					7											//	Определяем позицию  в регистре   TCCR2A для старшего бита выбора режима сравнения канала А
	#define COM2A0					6											//	Определяем позицию  в регистре   TCCR2A для младшего бита выбора режима сравнения канала А
	#define COM2B1					5											//	Определяем позицию  в регистре   TCCR2A для старшего бита выбора режима сравнения канала B
	#define COM2B0					4											//	Определяем позицию  в регистре   TCCR2A для младшего бита выбора режима сравнения канала B
	#define WGM21					1											//	Определяем позицию  в регистре   TCCR2A для 1 бита выбора режима работы таймера
	#define WGM20					0											//	Определяем позицию  в регистре   TCCR2A для 0 бита выбора режима работы таймера
	#define TCCR2B					(*(uint8_t*)0xB1)							//	Определяем смещение для регистра TCCR2B - рагистр делителя
	#define FOC2A					7											//	Определяем позицию  в регистре   TCCR2B для бита принудительной установки результата сравнения канала A
	#define FOC2B					6											//	Определяем позицию  в регистре   TCCR2B для бита принудительной установки результата сравнения канала B
	#define WGM22					3											//	Определяем позицию  в регистре   TCCR2B для 2 бита выбора режима работы таймера
	#define CS22					2											//	Определяем позицию  в регистре   TCCR2B для старшего бита выбора источника тактового сигнала таймера
	#define CS21					1											//	Определяем позицию  в регистре   TCCR2B для среднего бита выбора источника тактового сигнала таймера
	#define CS20					0											//	Определяем позицию  в регистре   TCCR2B для младшего бита выбора источника тактового сигнала таймера
	#define TCNT2					(*(uint8_t*)0xB2)							//	Определяем смещение для регистра TCNT2  - счётный регистр
	#define OCR2A					(*(uint8_t*)0xB3)							//	Определяем смещение для регистра OCR2A  - регистр сравнения канала A
	#define OCR2B					(*(uint8_t*)0xB4)							//	Определяем смещение для регистра OCR2B  - регистр сравнения канала B
	#define TIFR2					(*(uint8_t*)0x37)							//	Определяем смещение для регистра TIFR2  - регистр флагов
	#define OCF2B					2											//	Определяем позицию  в регистре   TIFR2  для флага совпадения значения счетного регистра TCNT2 с регистром сравнения OCR2A
	#define OCF2A					1											//	Определяем позицию  в регистре   TIFR2  для флага совпадения значения счетного регистра TCNT2 с регистром сравнения OCR2B
	#define TOV2					0											//	Определяем позицию  в регистре   TIFR2  для флага переполнения счетного регистра TCNT2
	#define TIMSK2					(*(uint8_t*)0x70)							//	Определяем смещение для регистра TIMSK2 - регистр разрешения прерываний
	#define OCIE2B					2											//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага OCF2B
	#define OCIE2A					1											//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага OCF2A
	#define TOIE2					0											//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага TOF2
	#define TIMER2_COMPA_vect_num	13											//	Определяем номер  вектора  для  события установки флага OCF2A
	#define TIMER2_COMPA_vect		_VECTOR(13)									//	Определяем вектор прерываний по событию установки флага OCF2A
	#define TIMER2_COMPB_vect_num	14											//	Определяем номер  вектора  для  события установки флага OCF2B
	#define TIMER2_COMPB_vect		_VECTOR(14)									//	Определяем вектор прерываний по событию установки флага OCF2B
	#define TIMER2_OVF_vect_num		15											//	Определяем номер  вектора  для  события установки флага TOV2
	#define TIMER2_OVF_vect			_VECTOR(15)									//	Определяем вектор прерываний по событию установки флага TOV2
#endif																			//
#endif																			//
																				//
class	iarduino_HC_SR04_tmr{													//
	public:							iarduino_HC_SR04_tmr(uint8_t, uint8_t);		//	Конструктор класса								(вывод TRIG, вывод ECHO)
		void						begin				(uint16_t=50);			//	Объявляем функцию инициализации датчика			(период опроса датчика в мс) от 50 до 3000.
		void						work				(bool);					//	Объявляем функцию включения/отключения датчика	(флаг)
		long						distance			(int8_t=23);			//	Объявляем функцию получения расстояния			([t°C]) от ±127.
		long						averaging			= 0;					//	Определяем коэффициент усреднения показаний		(0-без усреднений, 1-минимальное усреднение, ... 100-сильное усреднение, ... 2147483648-через день показания дойдут до реальных)
		static volatile	uint8_t		sumObj;										//	Объявляем  переменную для хранения количества подключённых датчиков.
		static volatile	uint8_t*	pinTRIG_PRT			[4];					//	Объявляем  массив для хранения указателя на адрес  регистра выходных значений вывода TRIG.
		static volatile	uint8_t*	pinECHO_PRT			[4];					//	Объявляем  массив для хранения указателя на адрес  регистра входных  значений вывода ECHO.
		static volatile	uint8_t		pinTRIG_MSK			[4];					//	Объявляем  массив для хранения маски вывода TRIG в регистре выходных значений.
		static volatile	uint8_t		pinECHO_MSK			[4];					//	Объявляем  массив для хранения маски вывода ECHO в регистре входных  значений.
		static volatile	uint16_t	cntECHO_HIGH		[4];					//	Объявляем  массив для подсчёта количества прерываний вызваных при наличии «1» на выводе ECHO.
		static volatile	uint16_t	cntECHO_LOW			[4];					//	Объявляем  массив для подсчёта количества прерываний вызваных при наличии «0» на выводе ECHO.
		static volatile	uint16_t	valECHO_DATA		[4];					//	Объявляем  массив для хранения количества прерываний вызваных при наличии «1» на выводе ECHO.
		static volatile	bool		flgECHO_LEVEL		[4];					//	Объявляем  массив для хранения предыдущего логического уровня на выводе ECHO.
		static volatile	bool		state				[4];					//	Объявляем  массив для хранения состояния датчика (вкл/выкл).
		static volatile	uint16_t	maxINT				[4];					//	Объявляем  массив для хранения количества прерываний таймера между опросом датчика.
	private:																	//
		void						funcSetTimer2		(uint32_t);				//	Объявляем  функцию конфигурирования 2 таймера.
		volatile uint8_t			numObj				= 0;					//	Определяем переменную для хранения номера экземпляра данного класса.
		float						valData;									//	Переменная для рассчета усреднённого результата.
};																				//
																				//
#endif																			//